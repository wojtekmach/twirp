defmodule Mix.Tasks.Compile.Twirp do
  use Mix.Task.Compiler

  @impl true
  def run(_) do
    protos = Path.wildcard("rpc/**/*.proto")
    prefix = "HelloWorld"
    generate_pb_modules(protos)
    generate_common_modules(prefix)
    generate_service_modules(prefix, protos)
    :ok
  end

  defp generate_pb_modules(protos) do
    protoc_erl_path = Path.join([Mix.Project.deps_paths()[:gpb], "bin", "protoc-erl"])

    args =
      [
        protoc_erl_path,
        "-modsuffix",
        "_pb",
        "-maps",
        "-strbin"
      ] ++ protos

    System.cmd("escript", args, into: IO.stream(:stdio, :line))
  end

  defp generate_common_modules(prefix) do
    File.write!("rpc/client.ex", """
    # Automatically generated by twirp-elixir, do not edit manually.
    defmodule #{prefix}.RPC.Client do
      @moduledoc false

      def call(url, pb_mod, service, rpc_name, request) do
        rpc = pb_mod.find_rpc_def(service, rpc_name)
        package_name = pb_mod.get_package_name()
        url = "#\{url}/#\{package_name}.#\{service}/#\{rpc_name}"
        request_pb = pb_mod.encode_msg(request, rpc.input)
        headers = [{"content-type", "application/protobuf"}]
        response_pb = post!(url, request_pb, headers)
        pb_mod.decode_msg(response_pb, rpc.output)
      end

      defp post!(url, pb, headers) do
        HTTPoison.post!(url, pb, headers).body
      end
    end
    """)

    File.write!("rpc/server.ex", """
    # Automatically generated by twirp-elixir, do not edit manually.
    defmodule HelloWorld.RPC.Server do
      @moduledoc false

      use Plug.Router
      plug(Plug.Logger)
      plug(:match)
      plug(:dispatch, builder_opts())

      post "/twirp/:service_name/:rpc_name" do
        pb_mod = opts[:pb_mod]
        handler = opts[:handler]
        {service_name, rpc_name} = pb_mod.fqbins_to_service_and_rpc_name(service_name, rpc_name)
        rpc = pb_mod.find_rpc_def(service_name, rpc_name)
        {:ok, request_pb, conn} = Plug.Conn.read_body(conn)
        request = pb_mod.decode_msg(request_pb, rpc.input)
        function = :"handle_#\{rpc_name}"
        result = apply(handler, function, [request])
        response_pb = pb_mod.encode_msg(result, rpc.output)

        conn
        |> put_resp_header("content-type", "application/protobuf")
        |> send_resp(200, response_pb)
      end

      match _ do
        send_resp(conn, 404, "oops")
      end

      def start_link(options) do
        children = [
          child_spec(options)
        ]

        http_options = Keyword.drop(options, [:pb_mod, :handler])

        message =
          "Starting #\{inspect(__MODULE__)} for #\{inspect(options[:handler])} with #\{inspect(http_options)}"

        require Logger
        Logger.info(message)

        Supervisor.start_link(children, strategy: :one_for_one, name: TwirpServer.Supervisor)
      end

      def child_spec(options) do
        options = Keyword.put_new(options, :port, 8080)
        {scheme, options} = Keyword.pop(options, :scheme, :http)
        {handler, options} = Keyword.pop(options, :handler)
        {pb_mod, options} = Keyword.pop(options, :pb_mod)
        plug = {__MODULE__, [handler: handler, pb_mod: pb_mod]}
        Plug.Cowboy.child_spec(scheme: scheme, plug: plug, options: options)
      end
    end
    """)
  end

  defp generate_service_modules(prefix, protos) do
    for proto <- protos do
      name = proto |> Path.basename() |> Path.rootname()
      service_root = Path.dirname(proto)
      source = String.to_charlist(Path.join(service_root, "#{name}_pb.erl"))
      {:ok, pb_module, binary} = :compile.file(source, [:binary, :report])
      :code.purge(pb_module)
      {:module, pb_module} = :code.load_binary(pb_module, source, binary)

      for service_name <- pb_module.get_service_names() do
        File.write!(Path.join(service_root, "#{name}_client.ex"), """
        # Automatically generated by twirp-elixir, do not edit manually.
        defmodule #{prefix}.RPC.#{service_name}Client do
          @moduledoc false

          def hello(url, params) do
            HelloWorld.RPC.Client.call(url, :hello_world_pb, :HelloWorld, :Hello, params)
          end
        end
        """)

        File.write!(Path.join(service_root, "#{name}_server.ex"), """
        # Automatically generated by twirp-elixir, do not edit manually.
        defmodule #{prefix}.RPC.#{service_name}Server do
          @moduledoc false

          def start_link(options) do
            options
            |> Keyword.put_new(:pb_mod, :hello_world_pb)
            |> HelloWorld.RPC.Server.start_link()
          end
        end
        """)
      end
    end
  end

  @impl true
  def clean() do
    Path.wildcard("rpc/**/*.{erl,ex}")
    |> Enum.each(&File.rm_rf!/1)
  end
end
